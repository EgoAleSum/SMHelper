<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

const SMHelper = {
    /**
     * From a dictionary, build the querystring part of a URL.
     * Resulting string can be appended to URLs after the `?` character.
     * 
     * Source: http://stackoverflow.com/a/1714899/192024
     * 
     * @param {object} obj - Dictionary with keys and values
     * @returns {string} The querystring that can be appended to URLs
     */
    buildQuerystring: (obj) => {
        const str = []
        for (const p in obj) {
            /* istanbul ignore else */
            if (obj.hasOwnProperty(p)) {
                // Skip undefined
                if (typeof obj[p] === 'undefined') {
                    continue
                }

                // Handle arrays
                if (Array.isArray(obj[p]) &amp;&amp; obj[p].length > 1) {
                    for (const i in obj[p]) {
                        let val = obj[p][i]
                        // Special case: handle the integer 0
                        if (val === 0) {
                            val = '0'
                        }
                        str.push(encodeURIComponent(p) + '[]' + (val ? ('=' + encodeURIComponent(val)) : ''))
                    }
                }
                else {
                    let val = obj[p]
                    // Handle arrays with one element
                    if (Array.isArray(val)) {
                        val = val[0]
                    }
                    // Special case: handle the integer 0
                    if (val === 0) {
                        val = '0'
                    }
                    str.push(encodeURIComponent(p) + (val ? ('=' + encodeURIComponent(val)) : ''))
                }
            }
        }
        return str.join('&amp;')
    },

    /**
     * Build a full HTTP/S URL from the various fragments.
     * 
     * @param {string} base - Base of the URL, including the protocol (e.g. `http://foo.bar/`)
     * @param {string|array} parts - Path, either as string or array (e.g. 'api/create' or ['api', 'create'])
     * @param {object} [args] - Dictionary with GET parameters
     * @returns {string} The full URL
     */
    buildUrl: (base, parts, args) => {
        base = base || ''
        parts = parts || []

        if (typeof parts === 'string') {
            parts = parts.split('/')
        }

        let append = parts.map(encodeURIComponent).join('/')

        if (args) {
            append += '?' + SMHelper.buildQuerystring(args)
        }

        if (base.length > 1 &amp;&amp; base.slice(-1) != '/') {
            base += '/'
        }

        return base + append
    },

    /**
     * Clone a JS object, deeply.
     * 
     * @param {*} obj - The object to clone (any scalar or non-scalar type)
     * @returns {*} The cloned object
     */
    cloneObject: (obj) => {
        // Return 'obj' itself if it's a scalar type or 'undefined'
        if (obj === undefined || SMHelper.isScalar(obj)) {
            return obj
        }
        // According to http://jsperf.com/cloning-an-object/13 this is the fastest way
        return JSON.parse(JSON.stringify(obj))
    },

    /**
     * Remove all empty properties from an object.
     * If "onlyNull", remove all `null` value only.
     * The object, which is passed by reference, is modified.
     * 
     * @param {object} obj - Object to compact
     * @param {boolean} [onlyNull=false] - If true, remove only values that are strictly `null`
     */
    compactObject: (obj, onlyNull) => {
        const recursive = (obj) => {
            for (const key in obj) {
                // Exclude non-own properties
                /* istanbul ignore next */
                if (!obj.hasOwnProperty(key)) {
                    continue
                }

                if (obj[key] === null || (!onlyNull &amp;&amp; !obj[key])) {
                    delete obj[key]
                }
                else if (typeof obj[key] === 'object') {
                    recursive(obj[key])

                    if (!Object.keys(obj[key]).length) {
                        // Delete empty objects
                        delete obj[key]
                    }
                }
            }
        }
        recursive(obj)
    },

    /**
     * Get a nested property from a dictionary or array, referenced by a string in "dot notation".
     * For example: "key1.key2.0"
     * 
     * Source: http://stackoverflow.com/a/8052100/192024
     * 
     * @param {object} obj - Object containing the property
     * @param {string} desc - Name of the nested property 
     * @returns {*} Value of the referenced property or `undefined`
     */
    getDescendantProperty: (obj, desc) => {
        const arr = desc.split('.')
        while (arr.length &amp;&amp; (obj = obj[arr.shift()])); // Leave the ; here!
        return obj
    },

    /**
     * Check if a value is numeric.
     * 
     * Sources: jQuery
     * https://github.com/jquery/jquery/blob/6acf4a79467a5aea5bc1eb7d552d72366718635d/src/core.js#L224
     * https://github.com/jquery/jquery/blob/6acf4a79467a5aea5bc1eb7d552d72366718635d/src/core.js#L271
     * Copyright (c) jQuery Foundation and other contributors
     * License: https://github.com/jquery/jquery/blob/master/LICENSE.txt
     * 
     * @param {*} obj - Value to analyze
     * @returns {boolean} True if value is numeric 
     */
    isNumeric: (obj) => {
        let type
        if (obj == null) {
            type = obj + ''
        }
        else {
            type = typeof obj === 'object' || typeof obj === 'function' ?
                'object' : typeof obj
        }

        return (type === 'number' || type === 'string') &amp;&amp;
            // parseFloat NaNs numeric-cast false positives ("")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            !isNaN(obj - parseFloat(obj))
    },

    /**
     * Check if a value is a plain object.
     * 
     * Source: http://stackoverflow.com/a/38555871/192024
     * 
     * @param {*} obj - Value to analyze
     * @returns {boolean} True if value is a plain object
     */
    isPlainObject: (obj) => {
        return	typeof obj === 'object'
            &amp;&amp; obj !== null
            &amp;&amp; obj.constructor === Object
            &amp;&amp; Object.prototype.toString.call(obj) === '[object Object]'
    },

    /**
     * Check if a value is of a scalar type (string, number, boolean).
     * 
     * Source: http://www.jsoneliners.com/function/is-scalar/
     * 
     * @param {*} obj - Value to analyze
     * @returns {boolean} True if value is of a scalar type
     */
    isScalar: (obj) => {
        return (/string|number|boolean/).test(typeof obj)
    },

    /**
     * Flatten a dictionary to the "dot notation", as used by MongoDB.
     * If preserveArrays is true, arrays are not transformed to the "dot notation".
     * 
     * Adapted from http://stackoverflow.com/questions/13218745/convert-complex-json-object-to-dot-notation-json-object
     * 
     * @param {object} obj - Dictionary to convert
     * @param {boolean} [preserveArrays=false] - If true, arrays are not transformed to the "dot notation"
     * @returns {object} Flattened dictionary in "dot notation"
     */
    objectToDotNotation: (obj, preserveArrays) => {
        const res = {}

        const recursive = (obj, current) => {
            for (const key in obj) {
                const value = obj[key]
                const newKey = (current ? current + '.' + key : key)
                if (value &amp;&amp; typeof value === 'object') {
                    if (preserveArrays &amp;&amp; Array.isArray(value)) {
                        res[newKey] = value
                    }
                    else {
                        recursive(value, newKey)
                    }
                }
                else {
                    res[newKey] = value
                }
            }
        }
        recursive(obj)

        return res
    },

    /**
     * Take `str` and put a backslash in front of every character that is part of the regular expression syntax.
     * Port of the PHP function "preg_quote". See also: http://php.net/preg_quote
     * 
     * Source: Locutus
     * https://github.com/kvz/locutus/blob/9aea421087656a4cf42decf9b032f28b145f0fdb/src/php/pcre/preg_quote.js
     * Copyright (c) 2007-2016 Kevin van Zonneveld
     * License: https://github.com/kvz/locutus/blob/9aea421087656a4cf42decf9b032f28b145f0fdb/LICENSE
     * 
     * @param {string} str - String to escape
     * @param {string} [delimiter] - If the optional delimiter is specified, it will also be escaped. This is useful for escaping the delimiter that is required by the regular expressions. The / is the most commonly used delimiter. 
     * @returns {string} Quoted (escaped) string
     */
    pregQuote: (str, delimiter) => {
        //  discuss at: http://locutus.io/php/preg_quote/
        // original by: booeyOH
        // improved by: Ates Goral (http://magnetiq.com)
        // improved by: Kevin van Zonneveld (http://kvz.io)
        // improved by: Brett Zamir (http://brett-zamir.me)
        // bugfixed by: Onno Marsman (https://twitter.com/onnomarsman)
        //   example 1: preg_quote("$40")
        //   returns 1: '\\$40'
        //   example 2: preg_quote("*RRRING* Hello?")
        //   returns 2: '\\*RRRING\\* Hello\\?'
        //   example 3: preg_quote("\\.+*?[^]$(){}=!&lt;>|:")
        //   returns 3: '\\\\\\.\\+\\*\\?\\[\\^\\]\\$\\(\\)\\{\\}\\=\\!\\&lt;\\>\\|\\:'

        return (str + '')
            .replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!&lt;>|:\\' + (delimiter || '') + '-]', 'g'), '\\$&amp;')
    },

    /**
     * Determine if a given string matches a pattern, allowing * as wildcard.
     * Ported from PHP, originally in Laravel 5.3 Str::is - See: https://github.com/laravel/framework/blob/v5.3.10/src/Illuminate/Support/Str.php#L119
     * 
     * Original copyright: Laravel
     * Copyright (c) Taylor Otwell
     * License: https://github.com/laravel/framework/blob/v5.3.10/LICENSE.md
     * 
     * @param {string} pattern - Pattern to search in value
     * @param {string} value - String in which the pattern is searched
     * @returns {boolean} True if value matches pattern
     */
    strIs: (pattern, value) => {
        if (pattern == value) return true
        if (pattern == '*') return true

        pattern = module.exports.pregQuote(pattern, '/')

        // Asterisks are translated into zero-or-more regular expression wildcards
        // to make it convenient to check if the strings starts with the given
        // pattern such as "library/*", making any string check convenient.
        const regex = new RegExp('^' + pattern.replace(/\\\*/g, '.*') + '$')

        return !!value.match(regex)
    },

    /**
     * Convert strings with dashes or underscores (eg. 'foo-bar' or 'foo_bar') to camelCase ('fooBar')
     * 
     * Adapted from: http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/comment-page-1/
     * 
     * @param {string} str - Dashed string
     * @returns {string} String converted to camelCase
     */ 
    stringToCamel: (str) => {
        return str.replace(/(-[a-z0-9]|_[a-z0-9])/g, ($1) => {
            return $1.toUpperCase().replace(/-|_/g, '')
        })
    },

    /**
     * Strip HTML tags, except allowed ones.
     * This function is a port of the PHP strip_tags function: http://php.net/strip_tags
     * 
     * Source: Locutus
     * https://github.com/kvz/locutus/blob/9aea421087656a4cf42decf9b032f28b145f0fdb/src/php/strings/strip_tags.js
     * Copyright (c) 2007-2016 Kevin van Zonneveld
     * License: https://github.com/kvz/locutus/blob/9aea421087656a4cf42decf9b032f28b145f0fdb/LICENSE
     * 
     * @param {string} input - Input string
     * @param {string} [allowed] - String listing allowed HTML tags, for example `&lt;br>`
     * @returns {string} String with HTML tags stripped
     */
    stripTags: (input, allowed) => {
        //  discuss at: http://locutus.io/php/strip_tags/
        // original by: Kevin van Zonneveld (http://kvz.io)
        // improved by: Luke Godfrey
        // improved by: Kevin van Zonneveld (http://kvz.io)
        //    input by: Pul
        //    input by: Alex
        //    input by: Marc Palau
        //    input by: Brett Zamir (http://brett-zamir.me)
        //    input by: Bobby Drake
        //    input by: Evertjan Garretsen
        // bugfixed by: Kevin van Zonneveld (http://kvz.io)
        // bugfixed by: Onno Marsman (https://twitter.com/onnomarsman)
        // bugfixed by: Kevin van Zonneveld (http://kvz.io)
        // bugfixed by: Kevin van Zonneveld (http://kvz.io)
        // bugfixed by: Eric Nagel
        // bugfixed by: Kevin van Zonneveld (http://kvz.io)
        // bugfixed by: Tomasz Wesolowski
        //  revised by: RafaÅ‚ Kukawski (http://blog.kukawski.pl)
        //   example 1: strip_tags('&lt;p>Kevin&lt;/p> &lt;br />&lt;b>van&lt;/b> &lt;i>Zonneveld&lt;/i>', '&lt;i>&lt;b>')
        //   returns 1: 'Kevin &lt;b>van&lt;/b> &lt;i>Zonneveld&lt;/i>'
        //   example 2: strip_tags('&lt;p>Kevin &lt;img src="someimage.png" onmouseover="someFunction()">van &lt;i>Zonneveld&lt;/i>&lt;/p>', '&lt;p>')
        //   returns 2: '&lt;p>Kevin van Zonneveld&lt;/p>'
        //   example 3: strip_tags("&lt;a href='http://kvz.io'>Kevin van Zonneveld&lt;/a>", "&lt;a>")
        //   returns 3: "&lt;a href='http://kvz.io'>Kevin van Zonneveld&lt;/a>"
        //   example 4: strip_tags('1 &lt; 5 5 > 1')
        //   returns 4: '1 &lt; 5 5 > 1'
        //   example 5: strip_tags('1 &lt;br/> 1')
        //   returns 5: '1  1'
        //   example 6: strip_tags('1 &lt;br/> 1', '&lt;br>')
        //   returns 6: '1 &lt;br/> 1'
        //   example 7: strip_tags('1 &lt;br/> 1', '&lt;br>&lt;br/>')
        //   returns 7: '1 &lt;br/> 1'

        // making sure the allowed arg is a string containing only tags in lowercase (&lt;a>&lt;b>&lt;c>)
        allowed = (((allowed || '') + '').toLowerCase().match(/&lt;[a-z][a-z0-9]*>/g) || []).join('')

        const tags = /&lt;\/?([a-z][a-z0-9]*)\b[^>]*>/gi
        const commentsAndPhpTags = /&lt;!--[\s\S]*?-->|&lt;\?(?:php)?[\s\S]*?\?>/gi

        return input.replace(commentsAndPhpTags, '').replace(tags, ($0, $1) => {
            return allowed.indexOf('&lt;' + $1.toLowerCase() + '>') > -1 ? $0 : ''
        })
    },

    /**
     * Convert a value to string, ensuring that the number 0 and the boolean false are treated correctly.
     * 
     * @param {*} val - Value to convert
     * @returns {string} String value
     */
    toStringSafe: (val) => {
        // Ensure str is a string
        if (typeof val == 'number' &amp;&amp; !isNaN(val)) {
            // Numbers have a special treatment to avoid having 0 converted to null
            val = val.toString()
        }
        else if (val === false) {
            val = 'false'
        }
        else {
            val = val ? val + '' : ''
        }

        return val
    },

    /**
     * Update a property (represented in the "dot notation") in an object.
     * The object is modified.
     * 
     * @param {object} obj - Object to the be updated
     * @param {string} property - Name of the property to update, in "dot notation"
     * @param {*} value - New value for the matched property
     */
    updatePropertyInObject: (obj, property, value) => {
        // Explode the dot notation
        const parts = property.split('.')
        const last = parts.pop()

        // Get the destination object
        let dest = obj
        for (let i = 0; i &lt; parts.length; i++) {
            if (dest[parts[i]] === undefined) {
                dest[parts[i]] = {}
            }
            dest = dest[parts[i]]

            // If the object is not a JS plain object, we can't update nested properties
            if (!SMHelper.isPlainObject(dest)) {
                throw Error('Cannot update nested property of something that is not an object')
            }
        }

        // Update the value
        dest[last] = value
    }
}

module.exports = SMHelper
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
